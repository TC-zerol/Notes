## 1.TCP/UDP区别与联系

1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

## 2. Map与HashMap了解么？ HashMap查找，插入时间复杂度？**

因为HashMap很少出现hash冲突了，因为哈希算法足够优秀，那么全是o（1）

但是当有链表的时候，那么就是o（n）的复杂度

如果转成红黑树 也就是二叉树的一种，那么应该是o（logN）的平均复杂度

## **3. 算法还记得么？快排实现方式，堆排实现方式？**

## **4. 使用递归的缺点？**

**优点：**

1、代码简洁

2、易于理解

如在树的前/中/后序遍历中，递归的实现明显比循环简单。 

**缺点：**

1、时间和空间的消耗比较大

递归由于是函数调用自身，而函数的调用时消耗时间和空间的，每一次函数调用，都需要在内存栈中分配空间以保存参数，返回值和临时变量，而往栈中压入和弹出数据也都需要时间，所以降低了效率。

2、重复计算

递归中又很多计算都是重复的，递归的本质时把一个问题分解成两个或多个小 问题，多个小问题存在重叠的部分，即存在重复计算，如斐波那契数列的递归实现。

3、调用栈溢出

递归可能时调用栈溢出，每次调用时都会在内存栈中分配空间，而栈空间的容量是有限的，当调用的次数太多，就可能会超出栈的容量，进而造成调用栈溢出。

**5.Set了解么？底层是什么实现的？**

底层还是map

**6.红黑树知道么？插入删除时间复杂度？**

**红黑树的时间复杂度为: O(lgn)**

性质1. 节点是红色或黑色。 [3] 

性质2. 根节点是黑色。 [3] 

性质3.所有叶子都是黑色。（叶子是NUIL节点） [3] 

性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）

性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 [3]

**10. 进程间通信方式？**

1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

**11. 面向对象的理解？**

（1）对象唯一性。

每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。 [2] 

（2）抽象性。

[抽象](https://baike.baidu.com/item/抽象)性是指将具有一致的[数据结构](https://baike.baidu.com/item/数据结构)（属性）和行为（操作）的对象[抽象](https://baike.baidu.com/item/抽象)成类。一个类就是这样一种[抽象](https://baike.baidu.com/item/抽象)，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。 [2] 

（3）继承性。

[继承性](https://baike.baidu.com/item/继承性)是子类自动共享父类[数据结构](https://baike.baidu.com/item/数据结构)和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 [2] 

继承性是[面向对象程序设计](https://baike.baidu.com/item/面向对象程序设计)语言不同于其它语言的最重要的特点，是其他语言所没有的。

在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。

在类层次中，子类继承了多个父类的数据结构和方法，则称为[多重继承](https://baike.baidu.com/item/多重继承)。

[多重继承](https://baike.baidu.com/item/多重继承)，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。

在[软件开发](https://baike.baidu.com/item/软件开发)中，类的[继承性](https://baike.baidu.com/item/继承性)使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了[对象](https://baike.baidu.com/item/对象)、类的创建工作量，增加了代码的可重用性。

采用[继承性](https://baike.baidu.com/item/继承性)，提供了类的规范的等级结构。通过类的[继承](https://baike.baidu.com/item/继承)关系，使公共的特性能够共享，提高了软件的重用性。 [2] 

（4）多态性（多形性）

[多态性](https://baike.baidu.com/item/多态性/4725624)是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。

多态性允许每个对象以适合自身的方式去响应共同的消息。

多态性增强了软件的灵活性和重用性。 [2]

## **13. 接口与抽象类的区别？**

### 1、概念的区别：

**抽象类**是从一些类中抽取出它们**共有的属性**（例如某些相同的成员变量、属性相同（修饰符、函数名、参数类型、参数个数）的方法），注意方法的修饰符可以为public或者protected（因为假如是private则子类无法继承），缺修饰符情况下默认为public，抽象类注重于对类本身的抽象，抽象方法没有方法体，仅仅是声明了该方法，让继承它的子类去实现。
而**接口**主要是对类的**行为的抽象**，接口也可以有变量和方法，但是变量以及方法的修饰符都必须分别是public static final（省略时也会默认是这个）和public abstract（省略时也会默认是这个）。

***\*注意\**：**
在java 8以后， 对接口做了新的修改，**允许接口有默认方法default**，即可以为接口添加实现方法，这样实现接口的类就不需要做任何的改动就能继承该接口所实现的该默认方法了；这样就使得接口与抽象类更相似了（因为抽象类不仅存在抽象方法，而且还可以有具体的已经实现了的方法）。

### 2、语法定义的区别：

**抽象类**通过 public abstract class 抽象类名字 {成员变量1…n; puclic abstract 返回类型 抽象方法名1…n(参数类型、参数名字1…n){};}来定义。抽象类还可以有不是抽象方法的方法。上两行只是说明了抽象方法的语法定义。
**接口**通过public interface 接口名字{public static final 成员变量1…n;public abstract 返回类 型 方法名1…n(参数类型、参数名字1…n){};}来定义。接口只能包含抽象方法（**这是以前**），在java 8以后可以包含默认的实现方法default（上面已经讲过了，这里再重复一遍）。

### 3、单继承与多继承的区别：

在java编程语言里，类与类之间只允许单继承，即一个类只能继承一个抽象类；但是一个类可以实现多个接口implements 接口1…n，实现多继承。

### 4、能否包含构造方法：

接口中不允许存在构造方法，因为接口的成员变量都是static final变量，是在编译的时候就完成了初始化操作了，也不需要通过构造方法来进行初始化操作，而接口的方法是抽象方法，和抽象类一样只是声明之后让实现它的类去完善该方法体的；而抽象类可以有构造方法，因为抽象类除了有抽象的方法以外，其余地方与普通的类其实是没什么区别的，所以可以通过构造方法完成一些初始化的操作。

### 相同点：

1、它们都不能被实例化，就是不能直接new()为它们分配空间，而是需要通过继承或者实现它们的类将它们实例化。
2、继承或者实现它们的类都必须实现它们所有的抽象方法。假如继承该抽象类的类没有全部实现抽象方法，则还是一个抽象类。