作者：拒绝职场pua
链接：https://www.nowcoder.com/discuss/292859?type=0&order=0&pos=23&page=1
来源：牛客网



## 1.直接上来就是问java的知识，原子类有使用过吗？ 

##   2.java中悲观锁和乐观锁的例子，各有什么缺点 

##   3.线程池了解吗，说一下。中间问了我核心线程数量一般设成多少，为什么。（我扯到了阿里使用线程池的规范，主要参数，工作队列等等） 

##   4.volatile关键词在双重检验单例下的作用，具体是解决了什么问题 

- **为什么要加Volatile关键字**

  其实，上面两点比较好理解，第三点，既然有了Synchronized作为限制，为什么还要加入Volatile呢？

  首先，我们需要知道Volatile可以保证可见性和原子性，同时保证JVM对指令不会进行重排序。
  其次，这点也很关键，对象的创建不是一步完成的，是一个符合操作，需要3个指令。
  我们结合这一句代码来解释：

```
singleton = new Singleton();  1
```

  指令1：获取singleton对象的内存地址
  指令2：初始化singleton对象
  指令3：将这块内存地址，指向引用变量singleton。

  那么，这样我们就比较好理解，为什么要加入Volatile变量了。由于Volatile禁止JVM对指令进行重排序。所以创建对象的过程仍然会按照指令1-2-3的有序执行。
  反之，如果没有Volatile关键字，假设线程A正常创建一个实例，那么指定执行的顺序可能2-1-3，当执行到指令1的时候，线程B执行getInstance方法，获取到的，可能是对象的一部分，或者是不正确的对象，程序可能就会报异常信息。

##   5.线程什么情况下会被中断，怎么中断 

（1）共享bool类型变量方式；
（2）调用线程interrupt方式，同时通过isInterrupted方式判断线程是否被停止，若停止则终止循环操作（线程类中循环外没有其他操作）；
（3）调用线程interrupt方式 ＋ 抛出异常方式（循环外有其他操作情况）；
（4）调用线程interrupt方式 ＋ return方式（循环外有其他操作情况）；
（5）将线程设置为守护线程，则所有非守护线程停止时，守护线程便结束；



种是可阻塞中断（调用wait、sleep,join 方法），一种是不可阻塞中断（争夺锁sychnrozied）。

##   6.notify和notifyAll的区别（我说完之后，感觉面试老师不满意，然后我问他老师我说得不对吗，结果面试官说他也忘记了，但是应该不是我说的这么简单。。。） 

1. Java提供了两个方法notify和notifyAll来唤醒在某些条件下等待的线程，你可以使用它们中的任何一个，但是Java中的notify和notifyAll之间存在细微差别，这使得它成为Java中流行的多线程面试问题之一。当你调用notify时，只有一个等待线程会被唤醒而且它不能保证哪个线程会被唤醒，这取决于线程调度器。虽然如果你调用notifyAll方法，那么等待该锁的所有线程都会被唤醒，但是在执行剩余的代码之前，所有被唤醒的线程都将争夺锁定，这就是为什么在循环上调用wait，因为如果多个线程被唤醒，那么线程是将获得锁定将首先执行，它可能会重置等待条件，这将迫使后续线程等待。因此，notify和notifyAll之间的关键区别在于notify（）只会唤醒一个线程，而notifyAll方法将唤醒所有线程。

##   7.线程有哪些状态，阻塞和sleep的区别？ 

阻塞：正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。

sleep（）和wait（）函数的区别：
（1）两者比较的共同之处是：两个方法都是使程序等待多少毫秒。
（2）最主要区别是：sleep（）方法没有释放锁。而wait（）方法释放了锁，使得其他线程可以使用同步控制块或者方法。
（3）sleep（）指线程被调用时，占着CPU不工作，形象的说明为“占着CPU”睡觉。
sleep(2000)表示：占用CPU，程序休眠2秒。
wait(2000)表示：不占用CPU，程序等待2秒。

##   8.Redis有用过吗，说说看。（我扯到了一面中被问到bitmap位图的应用） 

##   9.JVM模型大概说一下，GCRoots有哪些，垃圾收集[算法]()有哪些 

GC root有几下种

Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots。

Thread - 活着的线程

Stack Local - Java方法的local变量或参数

JNI Local - JNI方法的local变量或参数

JNI Global - 全局JNI引用

Monitor Used - 用于同步的监控对象

Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。

##   10.HashMap说一下，我刚准备说到[红黑树]()，老师就把我打断了，心里一凉，以为要我讲[红黑树]()的实现。结果问的是为什么引入[红黑树]()，然后为什么用[红黑树]()而不是其他平衡树（这里还和面试官略微讨论了一下，我说其他的平衡树更适合查找，像B树和B+树。[红黑树]()因为不用那么平衡，所以恢复平衡状态要做的操作少，插入2次旋转内，删除3次以内。然后老师说他认为[红黑树]()因为不用那么平衡所以查找效率更高？我当时脑抽了，下意识就问那为啥数据库索引不用平衡树而用B树和B+树呢，然后老师说他也不知道。。。） 

1. 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。
2. 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。
3. 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。
4. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。

##   11.HTTPS怎么实现的，解释下为什么是采用的混合加密，对称加密有什么缺点，非对称加密具体有哪些加密方法。怎么防止HTTPS被抓包 

[RSA](https://baike.baidu.com/item/RSA)、[Elgamal](https://baike.baidu.com/item/Elgamal)、背包算法、Rabin、D-H、[ECC](https://baike.baidu.com/item/ECC)（椭圆曲线加密算法）。

##   12.讲一下[项目]()，Spring讲一下（我讲了IOC，然后说到Spring解决循环依赖，AOP没讲） 

##   13.[项目]()中有什么印象深刻的（我这渣渣[项目]()有啥印象深刻的呀，扯了个自学SpringBoot时碰到Mybatis注入Bean时Idea报错的经历） 

##   14.平时遇到问题怎么解决，我说我一般先[百度]()。然后被打断了，问我为什么不用[google]()，github。。。我说有长城啊 

##   15.有啥问题要问的。因为比较想去杭州，我问杭州和上海部门的业务有啥区别，结果回答我他不知道杭州那边在搞什么，上海这边是做顺风车的。。。 

##   16.然后我问觉得我的表现怎么样，回答我理论知识还可以，但是觉得我实际操作能力不够，但是应届生都这样，要多看别人的技术博客。我就扯我之前看深入jvm虚拟机时GC回收时，那个动态年龄判定机制写得不太对，然后我在网上查阅了资料，blabla的。然后他说你不要去关注这种细节，因为GC一直在发展。。。



作者：光光_A.CMilan
链接：https://www.nowcoder.com/discuss/558618?type=0&order=0&pos=29&page=1&channel=-2&source_id=discuss_center_0
来源：牛客网

电话不是从杭州而是从上海打过来的，又是位气场极强的大佬，但人很好，手撕代码时候，一直引导我，第一题是个矩阵从中心由内向外按欧式距离遍历矩阵上所有的点，算是勉勉强强回答出来了；结果他说再考你一个[算法题]()，一个圆圈上分布多个数字，给个起点，从起点出发走固定步数，每步的方向不定，问有多少种方法可以走回原点？这一题当时脑子也有点懵，下意识就暴力破解去了，面试官说思路不行让我好好想想，其实之前遇到过这样的问题的，面试结束时候想起来应该用[动态规划]()哎...手撕完两道代码题，就简单问了我一下java内存模型？各种类型的生命周期啥的？这些都按以前复习准备的说了，但受前面手撕第二题没做出来的影响，回答的也是一般。最后让我反问他一个问题，估计是凉了，小伙伴们加油！



微服务啊分布式的概念，前后端分离优势以及[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)中有挑战的点和你的解决方案。