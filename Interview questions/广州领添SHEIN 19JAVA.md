部分资料来自于互联网，如有侵权请联系删除。

Part of the information comes from the Internet, please contact to delete if there is any infringement.

**1.自我介绍**



**2.直接问多线程，线程的状态，以及线程状态转换涉及的方法，wait和sleep是否释放cpu资源**

实现多线程的方法：1.继承Thread类；2实现Runnable接口；3.实现Callable接口通过FutureTask包装器来创建Thread线程；4.使用ExecutorService、Callable、Future实现有返回结果的多线程。

线程状态：

1.新建状态（NEW）：当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由jvm为其分配内存，并初始化其成员变量的值

2.就绪状态（RUNNABLE）：当线程对象调用了start（）方法之后，该线程就处于就绪状态。java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

3.运行态（RUNNING）：如果处于就绪状态的线程获得了CPU，开始执行run（）方法的线程执行体，则该线程就处于运行状态。

4.阻塞状态（BLOCKED）：阻塞状态是指线程因某种原因放弃了cpu使用权，也即让出了cpu timesliec， 暂时停止运行。知道线程进入可运行（RUNNING）状态，才能有机会再次获得cpu timeslice 转到运行（running）状态。



sleep()和wait()有什么区别：

1.对于sleep()方法，我们首先要知道该方法是属于Thread类中的，而wait()方法，则是属于Object类中的。

2.sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。

3.在调用sleep()方法的过长中，线程不会释放对象锁。

4.当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。



 **3.线程池参数，使用过哪个拒绝策略，线程池是哪个类**

7个参数：1.corePoolSize 线程池核心线程大小；2.maximumPoolSize 线程池最大线程数量;3.KeepAliveTime 空闲线程存活时间；4.unit 空间线程存回时间单位 5.workQueue 工作队列 6.threadFactory 线程工厂 7.headler 拒绝策略 。

拒绝策略：CallerRunsPolicy：在该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown了，则直接抛弃任务。

AbortPolicy：策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

DiscardPolicy：该策略下，直接丢弃任务，什么都不做。

DiscardOldestPolicy：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列

```java
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
```



 **4.连接池参数，连接池和线程池区别，用过哪些连接池**

连接池参数：最小连接数Min Pool size，最大连接数Max Pool size：默认为100。最大空闲时间；获取连接超时时间；超时重连接次数。

dbcp，Druid，jdbc



 **5.maven的作用优点，maven的生命周期**

maven主要是用来解决导入java类依赖的jar；编译java项目主要问题。

解决依赖和冲突问题。

jar包管理

Maven是基于项目对象模型，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。

相同的项目结构：使用Maven管理的Java 项目都有着相同的项目结构

统一维护jar包

maven生命周期：**1、clean生命周期**：清理项目，包含三个phase。

1）pre-clean：执行清理前需要完成的工作

2）clean：清理上一次构建生成的文件

3）post-clean：执行清理后需要完成的工作

**2、default生命周期**：构建项目，重要的phase如下。

1）validate：验证工程是否正确，所有需要的资源是否可用。
2）compile：编译项目的源代码。  
3）test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。
4）Package：把已编译的代码打包成可发布的格式，比如jar。
5）integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。
6）verify：运行所有检查，验证包是否有效且达到质量标准。
7）install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。
8）Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。

**3、site生命周期**：建立和发布项目站点，phase如下

1）pre-site：生成项目站点之前需要完成的工作

2）site：生成项目站点文档

3）post-site：生成项目站点之后需要完成的工作

4）site-deploy：将项目站点发布到服务器



 **6.mybatis常用的注解**

@Insert简单插入

```java
@Insert("insert into student(name,age) values(#{name},#{age})")
public void addStudent(Student student) throw Exception;
```

@Upload简单修改

```java
// 根据id修改姓名，方法的返回值代表修改的总数
@Updata("update student set name = ${arg0} where id = #{arg1}")
public Integer updateNameById(string name, Interger id) throws Exception;
```

@Delete简单删除

```java
// 根据id删除学生，方法的返回值代表删除的总数
@Delete("delete from student where id = #{id}")
public Integer deleteStudentById(Integer id) throws Exception;
```

@Select简单查询



 **7.四种引用（强软弱虚），分别如何实现（好像是这么问的，不太记得）**

java强引用：在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用就是一个强引用。当一个对象被强应用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被引用到JVM也不会回收，因此强引用是造成java内存泄露的主要原因之一。

java软引用：软引用需要用SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存不足时它会被回收，软引用通常用在内存敏感的程序中。

java弱引用：弱引用需要用WeakReference类来实现。它比软引用生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行。不管JVM的内存空间是否足够，总会回收该对象占用的内存。

java虚引用：虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪被垃圾回收的状态。

 **8.查看JVM堆和栈占用情况代码**

```java
MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
System.out.println(memoryMXBean.getHeapMemoryUsage());
System.out.println(memoryMXBean.getNonHeapMemoryUsage());
```

 **9.了解OOM么？如何让堆和栈溢出？**

java.lang.OutOfMemoryError:当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error。

**补充：java堆和栈**

栈内存：占内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

堆内存：存储的是数组和对象(其实数组就是对象)，凡事new建立的都是在堆中，堆中存放的都是实体（对象），实体对象用于封装数据，而且是封装多了（实体的多个属性），，如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。

程序计数器：当前线程执行的字节码的行号指示器，线程私有
JAVA虚拟机栈：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。
本地方法栈：类似“ JAVA虚拟机栈 ”，但是为native方法的运行提供内存环境。
JAVA堆：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。
方法区：用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。
运行时常量池：方法区的一部分，存储常量信息，如各种字面量、符号引用等。
直接内存：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。

 **10.zookeeper应用场景**

【1】数据发布与订阅。
【2】 负载均衡（软负载均衡）。
【3】命名服务。
【4】分布式通知/协调。
【5】集群管理与 Leader 选举。
【6】分布式锁。
【7】分布式队列。

 ZAB协议是一种专门为zookeeper设计的一种支持崩溃回复的原子广播协议，是一种通用的分布式一致性算法，基于该协议，zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。具体来说，zookeeper使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器数据的状态变更为以事务的形式广播到所有的副本进程上去，该协议的这个主备模式架构保证了同一时刻集群中只能够有一个主进程来广播服务器的状态变更。

选举机制：

于BasicLeaderElection算法的选举机制

基于FastLeaderElection算法的选举机制

 **11.分布式和集群的区别**

分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群是指同一种组件的多个实例，形成逻辑上的整体。

 **12.数据库四个隔离级别**

READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取未提交的数据变更，可能会导致读脏、幻读或不可重复读。

READ-COMMITTED(读取已提交)：允许读取并发事务已提交的数据，可以阻止读脏，但是幻读或不可重复读仍然有可能发生。

REPEATEABLE-READ（可重复读）：对同一个字段的多次读取结果都是一致的，除非数据是被本身事物自己所修改，可以阻止脏读和不可重复读，但是幻读仍有可能发生。

SERIALIZABLE（可串行化）：最高隔离级别，完全服从ACID的隔离级别。所以的事务依次逐个执行，这样事务之间就完全不可能产生干扰。

补充：读脏、幻读或不可重复读

读脏：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”

修改丢失：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修。

不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第
一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样

幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读区别：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

 **13.索引有哪些，哈希索引原理，索引越多越好？什么情况不建议建立索引**

主键索引(PRIMARY)

唯一索引(UNIQUE)

普通索引(INDEX)

全文索引(FULLTEXT)

限制索引的数目：越多的索引，会使更新表变得很浪费时间。尽量使用数据量少的索引



哈希索引原理:只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。



不建议建立索引:

　　1.频繁更新的字段不适合建立索引

　　2.where条件中用不到的字段不适合建立索引

　　3.表数据可以确定比较少的不需要建索引

　　4.数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值

　　5. 参与列计算的列不适合建索引

 **14.linux进程 内部 各种相关命令**

查看当前进程： ps

ps -ef (system v 输出)
ps -aux bsd 格式输出
ps -ef | grep pid

 **15.jsp和servlet区别，生命周期**

jsp和servlet的区bai别有以下几点：
Jsp是Servlet的一种简化，使用Jsp只需要完du成程序员需要输出到客户zhi端的内容，Jsp中的Java脚本如dao何镶嵌到一个类中，由Jsp容器完成。
1、jsp经编译后就变成了Servlet。
2、jsp更擅长表现于页面显示,servlet更擅长于逻辑控制。
3、Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletResponse对象以及HttpServlet对象得到。
4、而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应



理解JSP底层功能的关键就是去理解它们所遵守的生命周期。

JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。

以下是JSP生命周期中所走过的几个阶段：

- **编译阶段：**

  servlet容器编译servlet源文件，生成servlet类

- 初始化阶段：

  加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法

- 执行阶段：

  调用与JSP对应的servlet实例的服务方法

- 销毁阶段：

  调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例

 **16.java爬虫用到的包有哪些**

Jsoup、httpclient、fastjson、htmlunit

 **17.navicat优点作用，navicat连接数据库是不是一定要本地安装mysql**



 **18.消息队列知道的有哪些，ActiveMQ相关原理**

1. ActiveMQ：Apache旗下的老牌消息引擎
2. RabbitMQ、Kafka：AMQP的默认实现。
3. RocketMQ

作用：

解耦：解耦是消息队列需要解决的最本质问题。

最终一致性：最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。

广播：消息队列的基本功能之一是进行广播

错峰于流控：典型的使用场景就是秒杀业务用于流量削峰场景。