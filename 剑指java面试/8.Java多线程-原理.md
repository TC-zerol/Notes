# synchronized

## 现在安全的主要原因

存在共享数据（也称临界资源）

存在多条线程共同操作这些共享数据

解决问题的根本方法：

同一时刻有且有一个线程在操作共享数据，其他线程必须等到该线程处理完后再对共享数据进行操作

## 互斥锁的特性

互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一个时间只有一个线程对需要同步的代码块（复合操作）进行访问，互斥性也称为操作的原子性。

可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得改锁的另一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。

synchronized锁的不是代码，锁的是对象

## 更具获取的锁的分类：获取对象锁和获取类锁

获取对象锁的两种方法

1.同步代码块（synchronized（this），synchronized）（实例对象）），锁是小括号（）中的实例对象。

2.同步非静态方法（synchronized），锁是当前对象的实例对象

获得类锁

1.同步代码块（synchronized（类.class））,锁是小括号（）中的类对象（Class对象）。

2.同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）。

![image-20200923093525495](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923093525495.png)

## synchronized底层原理

### 对象在内存中的布局

对象头

<img src="F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923093702367.png" alt="image-20200923093702367" style="zoom: 80%;" />

<img src="F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923093839972.png" alt="image-20200923093839972" style="zoom:80%;" />

实例数据

对齐填充

### Monitor:每个Java对象天生自带了一把看不见的锁

### 什么是重入

从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入

### 为什么不常用synchronized

早期版本中，synchronized属于重量级锁，依赖Mutex Lock实现

线程之间的切换需要从用户态转换到内核态，开销较大



# 自旋锁与自适应锁

许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得

通过让线程执行忙循环等待锁的释放，不让出CPU

缺点：若锁被其他线程长时间占用，会带来许多性能上的开销



## 自适应自旋锁

自旋的次数不在固定

由前一次在同一个锁上的自旋时间及锁的拥有者的状态来确定



# 锁消除

JIT编译时，对上下文进行扫描，去除不可能存在竞争的锁



# 锁粗化

通过加锁的范围，避免反复的加锁解锁



# synchronized的四种状态

无锁、偏向锁、轻量级锁、重量级锁

<img src="F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923101045420.png" alt="image-20200923101045420" style="zoom:67%;" />



<img src="F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923101238459.png" alt="image-20200923101238459" style="zoom:80%;" />

![image-20200923101655001](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923101655001.png)

# synchronized和ReentrantLoack的区别

ReentrantLock（再入锁）

- 位于java.util.concurrent.locks包
- 和CountDownLatch、FutureTasK、Semaphore一样基于AQS实现
- 能够实现比synchronized更细粒度的控制，如控制fairness
- 调用lock(),必须调用unlock()释放锁
- 性能未必比synchronized高，并且也是可重入锁

## ReentrantLock公平性设置

- ReentrantLock = fairLock = new ReentrantLock(true);
- 当参数为true时，倾向于将锁赋予等待时间最久的线程
- 公平锁：获取锁的顺序按先后调用lock方法的顺序(慎用)
- 非公平锁：抢占的顺序不一定，看运气
- synchronized是非公平锁

## ReentrantLock将锁对象化

- 判断是否有线程，或者某个特定线程，在排队等待获取锁
- 带超时的获取锁的尝试
- 感知有没有成功获取锁

## 是否能将wait、notify、notifyAll对象化

java.util.concurrent.locks.Condition

![image-20200923103559489](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923103559489.png)



# Java内存模型JMM

Java内存模型（即Java Memory model）本身是一种抽象概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式

## JMM中的主内存

- 存储Java实例对象
- 包括成员变量、类信息、常量、静态变量
- 属于数据共享的区域，多线程并发操作时会引发线程安全问题

## JMM中的工作内存

- 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
- 字节码行号指示器，Native方法信息
- 属于线程私有数据区域，不存在线程安全问题

## 主内存与工作内存的数据存储类型以及操作方式归纳

- 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中
- 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中
- 成员变量、static变量，类信息均会被存储在主内存中
- 主内存共享的方式时线程各拷贝一份数据到工作内存，操作完成后刷新回主内存

![image-20200923162656688](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923162656688.png)

## 指令重排序需要满足的条件

在单线程环境下不能改变程序运行的结果

存在数据依赖的不允许重排序

无法通过happens-before原则推导出来的，才能进行指令重排序



## volatile变量为何立即可见

当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；

当读取一个volatile变量时，JMM会把该线程对应的工作内存设置为无效



## volatile如何禁止重排优化

内存屏障(Memory Barrier)

1.保证特定操作的执行顺序

2.保证某些变量的内存可见性

![image-20200923163727897](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923163727897.png)



# CAS(Compare and Swap)

一种高效实现线程安全的方法

- 支持原子更新操作，适用于计数器，序列发生器等场景
- 属于乐观锁机制，号称lock-free
- CAS操作失败时由开发者决定是继续尝试，还是执行别的操作



## CAS思想

包含三个操作数-内存位置V，预期值A，新值B



## CAS多数情况下对开发者来说是透明的

- J.U.C的atomic包提供了常用的原子性数据类型以及引用、数组等相关原子类型和跟新操作的工具，是很多线程安全程序的首选
- Unsafe类虽然提供了CAS服务，但因能够操纵任意内存地址读写而有隐患



# Java线程池

![image-20200923165103117](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923165103117.png)

  

## Fork/Join框架

把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务结果的框架

## 为什么要使用线程池

- 降低资源消耗
- 提高线程的可管理性

![image-20200923170000297](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170000297.png)

![image-20200923170337560](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170337560.png)

![image-20200923170459163](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170459163.png)

![image-20200923170704611](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170704611.png)

![image-20200923170734709](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170734709.png)

![image-20200923170756853](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170756853.png)

![image-20200923170907229](F:\java\Notes\剑指java面试\8.Java多线程-原理.assets\image-20200923170907229.png)

## 线程池的大小如何选定

CPU密集型：线程数=按照核数或者核数+1设定

I/O密集型：线程数=CPU核数*（1+平均等待时间/平均工作时间）