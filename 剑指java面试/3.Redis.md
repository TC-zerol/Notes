# 缓存

## 主流应用架构

<img src="F:\java\Notes\剑指java面试\3.Redis.assets\image-20200914093233762.png" alt="image-20200914093233762"  />

## 缓存中间件--Mencache和Redis的区别

### Memcache:代码底层类似Hash

支持简单数据类型

不支持数据持久化

不支持主从

不支持分配

### Redis

数据类型丰富

支持数据磁盘持久化存储

支持主从

支持分片 

## 为什么Redis能这么快

100000+QPS（QPS即query per second，每秒查询次数）

- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理高并发请求，想多核也可启动多实例
- 使用多路I/O复用模型，非阻塞IO

### 多路I/O复用模型

#### FD：File Descriptior，文件描述符

一个打开的文件同构唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射

### 传统的阻塞I/O模型

![image-20200914094717470](F:\java\Notes\剑指java面试\3.Redis.assets\image-20200914094717470.png)

### 多路复用模型

Redis采用的I/O多路复用函数：epoll/kqueue/evport/select



## Rdies的数据类型

### 供用户使用的数据类型

- String：最基本的数据类型，二进制安全
- Hash：String元素组成的字典，适用于存储对象
- List：列表，按照String元素插入顺序排序
- Set： String元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set：通过分数来为集合中的成员进行从大到小的排序

### 底层数据类型基础

1. 简单动态字符串
2. 链表
3. 字典
4. 跳跃表
5. 整数集合
6. 压缩列表
7. 对象



## 从海量Key里查询出某一固定前缀的Key

### 留意细节

- 摸清数据规模，即问清边界

### 使用keys对线上的业务的影响

#### KEYS pattern：查找所有符合给定模式pattern的key

- KEYS指令一次返回所有匹配的Key
- Key的数量过大，会使服务器卡顿

### SCAN cursor[MATCH pattern] [COUNT count]

- 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
- 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
- 不保证每次执行都返回某个给定数量的元素，支持模糊查询
- 一次返回的数量不可控，只能大概率符合count参数



## 如何通过Redis实现分布式锁

### 分布式锁需要解决的问题

- 互斥性
- 安全性
- 死锁
- 容错

### SETNX key value：如果key不存在，测创建并赋值

时间复杂度：O（1）

返回值：设置成功，返回1；设置失败，返回0

### 如何解决SETNX长期有效的问题

#### EXPIRE key second

- 设置key的生存时间，当key过期时（生存时间为0），会被自动删除
- 缺点：原子性得不到满足

#### SET key value [EX seconds] [PX milliseconds] [NX|XX]

### 大量的key同时过期

集中过期，由于清除大量的key很耗时，会出现短暂卡顿的现象

解决方法，在过期时间上加个随机值



## 如何使用Redis做异步队列

使用List作为队列，使用RPUSH生产信息，使用LPOP消费信息

缺点：没有等待队列里有值就直接消费

弥补：可以通过在应用层引入Sleep机制去调用LPOP重试

### BLPOP key [key...] timeout:阻塞到直到队列有消息或者超时

### pub/sub：主题订阅者模式

- 发送者（pub）发送消息，订阅者（sub）接受消息

- 订阅者可以订阅任意数量的频道

缺点发布消息是无状态的，不发保证可达



## Redis如果做持久化

RDB(快照)持久化：保存某个时间点的全量数据快照

SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕

BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程

###  自动触发RDB持久化的方式

- 根据redis.conf配置里的SAVE m n定时触发(用的是BGSAVE)
- 主从复制时，主节点自动触发
- 执行Debug Reload
- 执行Shutdown且并没开启AOF持久化

### BGSAVE的原理

#### Copy-on-Write

如果有多个调用者同时要求相同的资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变，

### 缺点

内存数据的全量同步，数据量大会由于I/O二严重影响性能

可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据

### AOF（Append-Only-File）持久化：保存写状态

- 记录下除查询以外的所有变更数据库状态指令

- 以append的形式追加保存到AOF文件中（增量）

#### 日志重写解决AOF文件大小不断增大的问题，原理如下：

- 调用fork（），创建一个子进程
- 子进程把新的AOF写到一个临时文件中，不依赖原来的AOF文件
- 主进程持续将新的变动同时写到内存和原来的AOF里
- 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动
- 使用新的AOF文件替换掉旧的AOF文件



## Redis数据的恢复

### RDB和AOF文件共存情况下的恢复流程

<img src="F:\java\Notes\剑指java面试\3.Redis.assets\image-20200914161247569.png" alt="image-20200914161247569" style="zoom: 67%;" />



## 使用PIpeline的好处

- Pipeline和Linux的管道类似
- Redis基于请求/响应模型，单个请求处理要一一应答
- Pipeline批量执行指令，节省多次IO往返的时间
- 有顺序依赖的指令建议分批发送

### Redis的同步配置

#### 主从同步原理

<img src="F:\java\Notes\剑指java面试\3.Redis.assets\image-20200914161815348.png" alt="image-20200914161815348" style="zoom:50%;" />

#### 全同步过程

- Slave发送sync命令到Master
- Master启动一个后台进程，将Redis中的数据快照保存到文件中
- Master将保存数据快照期间接受到的写命令缓存起来
- Master完成写文件操作后，将该文件发送给Slave
- 使用新的AOF文件替换掉旧的AOF文件
- Master将这期间的收集的增量写命令发送给Slave端

#### 增量同步过程

-  Master接收到用户的操作指令，判断是否需要传播到Slave
- 将操作记录追加到AOF文件
- 将操作传播到其他Slave：1、对齐主从库；2、往响应缓存写入指令
- 将缓存中的数据发送给Slavez

### Redis Sentinel

解决主从同步Master宕机后主从切换问题

- 监控：检查主从服务器是否运行正常
- 提醒：通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换

### 流言协议Gossip

在杂乱无章中寻求一致

- 每个节点随机地与对方通信，最终所有节点的状态达成一致
- 种子节点定期随机向其他节点发送节点列表以及所需要传播的消息
- 不保证消息一定会传递给所有节点，但是最终会趋向一致



## Redis集群

如何从海量数据里快速找到所需？

- 分片：按照某种规则去划分数据，分散存储在多个节点上
- 常规的按照哈希划分无法实现节点的动态增加或减少

一致性哈希算法：对2^32取模，将哈希值空间组织成虚拟圆环



